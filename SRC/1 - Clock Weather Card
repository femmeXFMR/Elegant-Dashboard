# home_header_welcome_weather.yaml
# Purpose:
#   Glassmorphic Home header that:
#     - Hides the HA top bar in kiosk mode
#     - Shows a live doorbell camera when enabled
#     - Otherwise shows a welcome title, animated weather header,
#       sun arc / lunar phase, 5-day forecast bars, and a 12-hour temp chart.
#
# Dependencies (custom cards / plugins):
#   - custom:mod-card  (with card-mod)
#   - custom:layout-card
#   - custom:button-card
#   - custom:stack-in-card
#
# Required entities:
#   - input_boolean.doorbell_camera_active
#   - camera.front_door_bell_live_view
#   - weather.forecast_abode
#   - sensor.tomorrow_raw_hourly  (Tomorrow.io-style hourly timeline)
#   - sensor.time
#   - sun.sun
#   - sensor.moon_phase
#
# Required assets:
#   - /local/weather-icons/weather-icons-master/design/line/animation-ready/*.svg
#   - /local/weather-icons/weather-icons-master/design/fill/animation-ready/*.svg
#
# To adapt:
#   - Replace all entity IDs above with your own equivalents.
#   - Point the icon <img src="..."> paths to your own weather icon folder.
#   - Remove or tweak the kiosk-mode CSS if you don't use kiosk mode.

type: custom:mod-card
style:
  .: |
    ha-card {
      width: 100%;
      margin: 0 auto;
      padding: 0;
      background: none;
      box-shadow: none;
    }

    /* Hide top bar when kiosk-mode is ON */
    body:has(hui-view[kiosk-mode="on"]) app-header,
    body:has(hui-view[kiosk-mode="on"]) app-toolbar {
      display: none !important;
    }
card:
  type: vertical-stack
  cards:
    - type: conditional
      conditions:
        - entity: input_boolean.doorbell_camera_active
          state: "on"
      card:
        type: picture-entity
        entity: camera.front_door_bell_live_view
        camera_view: live
        show_name: false
        show_state: false
        card_mod:
          style: |
            ha-card {
              border-radius: 24px;
              overflow: hidden;
              box-shadow: 0 6px 30px rgba(0, 0, 0, 0.4);
              height: 420px;
            }
    - type: conditional
      conditions:
        - entity: input_boolean.doorbell_camera_active
          state: "off"
      card:
        type: vertical-stack
        cards:
          - type: markdown
            content: |
              Welcome Abode ðŸ™
            card_mod:
              style: |
                ha-card {
                  margin-top: -20px !important;
                  background: none;
                  box-shadow: none;
                  padding: 0px;
                  font-size: 20px;
                  font-weight: 400;
                  color: white;
                  text-align: left;
                }
          - type: custom:mod-card
            card_mod:
              style: |
                ha-card {
                  width: 100% !important;
                  margin-top: -40px !important;
                  background: none;
                  box-shadow: none;
                  margin-bottom: -40px !important;
                }
            card:
              type: custom:layout-card
              layout_type: grid
              layout:
                grid-template-columns: 2fr 1fr
                column-gap: 12px
                align-items: center
              cards:
                - type: custom:button-card
                  name: |
                    [[[              
                      const weather = states['weather.forecast_abode']?.state ?? 'Partlycloudy';
                      const temp = states['weather.forecast_abode']?.attributes?.temperature ?? '--';
                      const time = states['sensor.time']?.state ?? '--:--';
                      const now = new Date();
                      const day = String(now.getDate()).padStart(2, '0');
                      const month = String(now.getMonth() + 1).padStart(2, '0');
                      const year = String(now.getFullYear()).toString().slice(-2);
                      const weekday = now.toLocaleDateString('en-GB', { weekday: 'long' });
                      const dateStr = `${weekday}, ${day}.${month}.${year}`;

                      

                      const isNight = states['sun.sun']?.state === 'below_horizon';

                      const map = {
                        'clear':        isNight ? 'clear-night' : 'clear-day',
                        'clear-night':  isNight ? 'clear-night' : 'clear-day',
                        'sunny':        isNight ? 'clear-night' : 'clear-day',
                        'partlycloudy': isNight ? 'partly-cloudy-night' : 'partly-cloudy-day',
                        'cloudy':       isNight ? 'overcast-night' : 'overcast',
                        'rainy':        isNight ? 'partly-cloudy-night-drizzle' : 'drizzle',
                        'pouring':      isNight ? 'partly-cloudy-night-rain' : 'rain',
                        'snowy':        isNight ? 'partly-cloudy-night-snow' : 'snow',
                        'snowy-rainy':  isNight ? 'partly-cloudy-night-sleet' : 'sleet',
                        'windy':        'wind',
                        'windy-variant':'wind',
                        'fog':          isNight ? 'fog-night' : 'fog-day',
                        'hail':         isNight ? 'partly-cloudy-night-hail' : 'partly-cloudy-day-hail',
                        'lightning':    isNight ? 'thunderstorms-night' : 'lightning-bolt',
                        'lightning-rainy': isNight ? 'thunderstorms-night-rain' : 'thunderstorms-rain',
                        'exceptional':  'tornado'
                      };

                      // PROPERLY FORMAT CONDITION
                      function formatCondition(condition) {
                        // Handle known ones manually
                        const manualMap = {
                          partlycloudy: 'Partly Cloudy',
                          clearnight: 'Clear Night',
                          clearday: 'Clear Day',
                          lightrain: 'Light Rain',
                          heavyrain: 'Heavy Rain',
                          lightningrainy: 'Lightning Rainy',
                          snowy: 'Snowy',
                          snowyrainy: 'Snowy Rainy',
                          windyvariant: 'Windy Variant'
                        };

                        if (manualMap[condition.toLowerCase()]) {
                          return manualMap[condition.toLowerCase()];
                        }

                        // Otherwise just split at dash (-) or default
                        return condition
                          .replace(/-/g, ' ')
                          .split(' ')
                          .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                          .join(' ');
                      }

                      const conditionFormatted = formatCondition(weather);

                      const iconKey = map[weather.toLowerCase()] ?? 'cloudy';
                      const iconPath = `/local/weather-icons/weather-icons-master/design/line/animation-ready/${iconKey}.svg`;

                      return `
                        <div style="display: flex; align-items: flex-start;">
                          <div style="width: 100px; height: 100px; margin-right: 20px;">
                            <img src="${iconPath}" style="width: 100%; height: 100%; object-fit: contain;" />
                          </div>
                          <div>
                            <div style="font-size: 12px; font-weight: 300;">${conditionFormatted}, ${temp}Â°C</div>
                            <div style="font-size: 48px; font-weight: 400;">${time}</div>
                            <div style="font-size: 12px;">${dateStr}</div>
                          </div>
                        </div>
                      `;
                    ]]]
                  show_icon: false
                  show_state: false
                  styles:
                    card:
                      - background: none
                      - box-shadow: none
                      - color: white
                      - padding: 0
                      - height: 120px
                    name:
                      - white-space: normal
                - type: custom:button-card
                  show_icon: false
                  show_state: false
                  styles:
                    card:
                      - background: none
                      - box-shadow: none
                      - padding: 0
                      - height: 130px
                    name:
                      - white-space: normal
                  name: |
                    [[[              
                      const sun = states['sun.sun'];
                      const time = states['sensor.time']?.state ?? "00:00";
                      const moon = states['sensor.moon_phase']?.state ?? 'unknown';
                      const isNight = sun.state === 'below_horizon';

                      const moonIcons = {
                        new_moon: 'ðŸŒ‘', waxing_crescent: 'ðŸŒ’', first_quarter: 'ðŸŒ“',
                        waxing_gibbous: 'ðŸŒ”', full_moon: 'ðŸŒ•', waning_gibbous: 'ðŸŒ–',
                        last_quarter: 'ðŸŒ—', waning_crescent: 'ðŸŒ˜'
                      };
                      const moonIcon = moonIcons[moon] ?? 'ðŸŒ™';

                      const toMinutes = (t) => {
                        const d = new Date(t);
                        return d.getHours() * 60 + d.getMinutes();
                      };

                      const sunriseMin = toMinutes(sun.attributes.next_rising);
                      const sunsetMin = toMinutes(sun.attributes.next_setting);
                      const nowMin = parseInt(time.split(":")[0]) * 60 + parseInt(time.split(":")[1]);

                      const solarNoonMin = Math.floor((sunriseMin + sunsetMin) / 2);
                      const solarNoon = `${String(Math.floor(solarNoonMin / 60)).padStart(2, '0')}:${String(solarNoonMin % 60).padStart(2, '0')}`;

                      const moonPct = isNight
                        ? nowMin < sunriseMin
                          ? (nowMin + 1440 - sunsetMin) / (1440 - sunsetMin + sunriseMin)
                          : (nowMin - sunsetMin) / (1440 - sunsetMin + sunriseMin)
                        : 0;

                      const sunPct = (nowMin - sunriseMin) / (sunsetMin - sunriseMin);

                      const r = 90;
                      const cx = 120;
                      const cy = 110;
                      const moonAngle = moonPct * Math.PI;
                      const sunAngle = sunPct * Math.PI;
                      const moon_x = cx + r * Math.cos(moonAngle - Math.PI);
                      const moon_y = cy - r * Math.sin(moonAngle);
                      const sun_x = cx + r * Math.cos(sunAngle - Math.PI);
                      const sun_y = cy - r * Math.sin(sunAngle);

                      const sr = new Date(sun.attributes.next_rising).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                      const ss = new Date(sun.attributes.next_setting).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

                      let stars = '';
                      for (let i = 0; i < 25; i++) {
                        const sx = Math.floor(30 + Math.random() * 180);
                        const sy = Math.floor(20 + Math.random() * 70);
                        const r = (Math.random() * 1.5 + 0.5).toFixed(1);
                        const dur = (Math.random() * 2 + 1).toFixed(1);
                        stars += `
                          <circle cx="${sx}" cy="${sy}" r="${r}" fill="white" opacity="0.8">
                            <animate attributeName="opacity" values="0.2;0.8;0.2" dur="${dur}s" repeatCount="indefinite" />
                          </circle>
                        `;
                      }

                      return `
                        <svg viewBox="0 0 240 160" width="100%" height="160">
                          <defs>
                            <linearGradient id="skyGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                              <stop offset="0%" stop-color="rgba(130, 177, 255, 0.35)" />
                              <stop offset="100%" stop-color="rgba(30, 58, 138, 0.2)" />
                            </linearGradient>
                            <linearGradient id="nightGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                              <stop offset="0%" stop-color="rgba(44, 62, 80, 0.4)" />
                              <stop offset="100%" stop-color="rgba(20, 30, 48, 0.2)" />
                            </linearGradient>
                            <filter id="glassBlur">
                              <feGaussianBlur stdDeviation="4" />
                            </filter>
                            <linearGradient id="lightArc" x1="0%" y1="0%" x2="100%" y2="0%">
                              <stop offset="0%" stop-color="#ffee99" stop-opacity="1"/>
                              <stop offset="100%" stop-color="#ffee99" stop-opacity="0"/>
                            </linearGradient>
                            <filter id="arcGlow">
                              <feGaussianBlur stdDeviation="2.5" result="blur"/>
                              <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
                            </filter>
                            <filter id="glow">
                              <feGaussianBlur stdDeviation="2.5" result="blur"/>
                              <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
                            </filter>
                          </defs>

                          <path d="M30 110 A90 90 0 0 1 210 110" fill="${isNight ? 'url(#nightGradient)' : 'url(#skyGradient)'}" filter="url(#glassBlur)" stroke="none" />
                          ${isNight ? stars : ''}
                          <path d="M30 110 A90 90 0 0 1 210 110" stroke="url(#lightArc)" stroke-width="3.5" fill="none" filter="url(#arcGlow)" />

                          ${isNight
                            ? `<text x="${moon_x}" y="${moon_y}" font-size="28" text-anchor="middle" dominant-baseline="middle" filter="url(#glow)">${moonIcon}</text>`
                            : `<circle cx="${sun_x}" cy="${sun_y}" r="10" fill="#FFD93B" filter="url(#glow)">
                                <animate attributeName="cy" values="${sun_y + 4};${sun_y - 4};${sun_y + 4}" dur="2s" repeatCount="indefinite"/>
                              </circle>`
                          }

                          ${isNight
                            ? `<text x="120" y="2" font-size="16" fill="white" text-anchor="middle" font-weight="regular">Lunar Phase</text>`
                            : `<circle cx="120" cy="20" r="2" fill="#aaa"/>
                               <text x="120" y="46" font-size="16" fill="white" text-anchor="middle">Noon</text>
                               <text x="120" y="60" font-size="14" fill="white" text-anchor="middle">${solarNoon}</text>

                               <text x="30" y="132" font-size="16" fill="white" text-anchor="start">Sunrise</text>
                               <text x="30" y="146" font-size="14" fill="white" text-anchor="start">${sr}</text>

                               <text x="210" y="132" font-size="16" fill="white" text-anchor="end">Sunset</text>
                               <text x="210" y="146" font-size="14" fill="white" text-anchor="end">${ss}</text>`
                          }
                        </svg>
                      `;
                    ]]]
          - type: custom:stack-in-card
            card_mod:
              style: |
                ha-card {
                  width: 100% !important;
                  background: none !important;
                  box-shadow: none !important;
                  margin-top: -10px;  
                  padding-top: 0px;
                  padding-bottom: 12px;
            cards:
              - type: custom:mod-card
                style:
                  .: |
                    ha-card {
                      width: 100%;
                      margin: 0 auto;
                      padding: 0;
                      background: none;
                      box-shadow: none;
                    }
                card:
                  type: vertical-stack
                  cards:
                    - type: custom:button-card
                      entity: sensor.tomorrow_raw_hourly
                      card_mod:
                        style: |
                          ha-card {
                            margin-top: 8px !important;
                            margin-bottom: -8px !important;     
                          }
                      variables:
                        dayOffset: 0
                      show_name: false
                      show_icon: false
                      show_state: false
                      layout: grid
                      styles:
                        grid:
                          - grid-template-areas: "\"day icon min bar max\""
                          - grid-template-columns: 2.5em 2em 3em 1fr 3em
                          - align-items: center
                          - column-gap: 0.4em
                        card:
                          - padding: 0.6em 0.8em
                          - background: none
                          - box-shadow: none
                          - border-radius: 0.8em
                          - height: 1.5em
                        custom_fields:
                          day:
                            - font-size: 0.8em
                          min:
                            - font-size: 0.8em
                          max:
                            - font-size: 0.8em
                      custom_fields:
                        day: |
                          [[[
                            const offset = variables.dayOffset || 0;
                            const today = new Date();
                            today.setUTCHours(0,0,0,0);
                            const target = new Date(today.getTime() + offset * 86400000);
                            return target.toLocaleDateString('en-GB', { weekday: 'short' });
                          ]]]
                        icon: |
                          [[[
                            const offset = variables.dayOffset || 0;
                            const hourly = entity?.attributes?.timelines?.hourly || [];
                            const iconMap = {
                              1000: 'clear-day',
                              1100: 'partly-cloudy-day',
                              1101: 'partly-cloudy-day',
                              1102: 'partly-cloudy-day',
                              1001: 'cloudy',
                              2000: 'fog',
                              2100: 'fog',
                              4000: 'drizzle',
                              4001: 'rain',
                              4200: 'rain',
                              4201: 'rain',
                              5000: 'snow',
                              5001: 'snow',
                              5100: 'snow',
                              5101: 'snow',
                              6000: 'freezing-rain',
                              6001: 'freezing-rain',
                              6200: 'freezing-rain',
                              6201: 'freezing-rain',
                              7000: 'ice-pellets',
                              7101: 'ice-pellets',
                              7102: 'ice-pellets',
                              8000: 'thunderstorm'
                            };

                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            const targetDate = new Date(today);
                            targetDate.setDate(targetDate.getDate() + offset);

                            const data = hourly.filter(h => {
                              const t = new Date(h.time);
                              return t.getFullYear() === targetDate.getFullYear() &&
                                     t.getMonth() === targetDate.getMonth() &&
                                     t.getDate() === targetDate.getDate();
                            });

                            const code = data[12]?.values?.weatherCode || 1000;
                            const icon = iconMap[code] || 'cloudy';
                            return `<img src="/local/weather-icons/weather-icons-master/design/fill/animation-ready/${icon}.svg" style="height:1.6em;" />`;
                          ]]]
                        min: |
                          [[[
                            const h = entity.attributes.timelines.hourly;
                            const offset = variables.dayOffset || 0;
                            const base = new Date();
                            base.setUTCHours(0,0,0,0);
                            const start = new Date(base.getTime() + offset * 86400000);
                            const end = new Date(start.getTime() + 86400000);
                            const temps = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            }).map(i => i.values.temperature);
                            const min = Math.min(...temps);
                            return isFinite(min) ? `${Math.round(min)}Â°C` : '';
                          ]]]
                        max: |
                          [[[
                            const h = entity.attributes.timelines.hourly;
                            const offset = variables.dayOffset || 0;
                            const base = new Date();
                            base.setUTCHours(0,0,0,0);
                            const start = new Date(base.getTime() + offset * 86400000);
                            const end = new Date(start.getTime() + 86400000);
                            const temps = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            }).map(i => i.values.temperature);
                            const max = Math.max(...temps);
                            return isFinite(max) ? `${Math.round(max)}Â°C` : '';
                          ]]]
                        bar: |
                          [[[
                            const h = entity.attributes.timelines.hourly;
                            const offset = variables.dayOffset || 0;
                            const base = new Date();
                            base.setUTCHours(0, 0, 0, 0);
                            const start = new Date(base.getTime() + offset * 86400000);
                            const end = new Date(start.getTime() + 86400000);
                            const temps = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            }).map(i => i.values.temperature);
                            if (!temps.length) return '';

                            const allTemps = entity.attributes.timelines.hourly
                              .slice(0, 120)
                              .map(i => i.values.temperature);
                            const overallMin = Math.min(...allTemps);
                            const overallMax = Math.max(...allTemps);

                            const min = Math.min(...temps);
                            const max = Math.max(...temps);
                            const left = ((min - overallMin) / (overallMax - overallMin)) * 100;
                            const rawWidth = ((max - min) / (overallMax - overallMin)) * 100;
                            const width = Math.max(rawWidth, 15);  // Ensure minimum 15% width

                            // FIX: Calculate the correct background size and position
                            // 1. Calculate how much wider the background needs to be than the bar itself.
                            //    If the bar is 50% wide, the background needs to be 200% wide.
                            const bgSize = 100 / (width / 100);

                            // 2. Calculate the horizontal position of the background.
                            //    This shifts the oversized background so the correct color slice is visible.
                            const bgPos = left / (100 - width) * 100;


                            // Rain chance
                            const rainHours = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            });
                            const rainChances = rainHours.map(i => i.values.precipitationProbability || 0);
                            const maxRain = Math.round(Math.max(...rainChances));
                            const rainLabel = `${maxRain}%`;

                            const id = Math.random().toString(36).substring(2, 9);

                            return `
                              <style>
                                @keyframes fillAnim-${id} {
                                  from { transform: scaleX(0); opacity: 0.3; }
                                  to { transform: scaleX(1); opacity: 1; }
                                }
                                @keyframes drip {
                                  0% { transform: translateY(0); opacity: 0.9; }
                                  50% { transform: translateY(2px); opacity: 0.5; }
                                  100% { transform: translateY(0); opacity: 0.9; }
                                }
                              </style>
                              <div style="
                                position: relative;
                                width: 100%;
                                height: 1.1em;
                                border-radius: 1em;
                                overflow: hidden;
                                background: rgba(255, 255, 255, 0.02);
                                backdrop-filter: blur(8px);
                                -webkit-backdrop-filter: blur(8px);
                                box-shadow:
                                  inset 0 0 1px rgba(255, 255, 255, 0.15),
                                  inset 0 0 1px rgba(144, 255, 200, 0.25);
                              ">
                                <div style="
                                  position: absolute;
                                  top: 0;
                                  bottom: 0;
                                  left: ${left}%;
                                  width: ${width}%;
                                  transform-origin: left;
                                  transform: scaleX(0);
                                  background: linear-gradient(to right, #51fcd4, #fff06e, #ffb347);
                                  /* FIX: Apply the calculated size and position */
                                  background-size: ${bgSize}% 100%;
                                  background-position: ${bgPos}% 0%;
                                  border-radius: 1em;
                                  box-shadow:
                                    inset 1px 1px 2px rgba(255, 255, 255, 0.5),
                                    inset -1px -1px 2px rgba(0, 0, 0, 0.05),
                                    0 0 8px rgba(144, 255, 200, 0.5),
                                    0 0 12px rgba(255, 170, 200, 0.2);
                                  backdrop-filter: blur(6px);
                                  -webkit-backdrop-filter: blur(6px);
                                  animation: fillAnim-${id} 1.4s ease-out 3.2s forwards;
                            
                                  display: flex;
                                  align-items: center;
                                  justify-content: center;
                                  font-size: 0.6em;
                                  font-weight: bold;
                                  color: rgba(30, 20, 80, 0.95);
                                  text-shadow: 0 0 1px rgba(255, 255, 255, 0.7);
                                ">
                                  <div style="display: flex; gap: 0.2em; align-items: center;">
                                    <span style="animation: drip 1.2s infinite ease-in-out;">ðŸ’§</span>
                                    <span>${rainLabel}</span>
                                  </div>
                                </div>
                              </div>
                            `;
                          ]]]
                    - type: custom:button-card
                      entity: sensor.tomorrow_raw_hourly
                      card_mod:
                        style: |
                          ha-card {
                            margin-bottom: -8px !important;     
                          }
                      variables:
                        dayOffset: 1
                      show_name: false
                      show_icon: false
                      show_state: false
                      layout: grid
                      styles:
                        grid:
                          - grid-template-areas: "\"day icon min bar max\""
                          - grid-template-columns: 2.5em 2em 3em 1fr 3em
                          - align-items: center
                          - column-gap: 0.4em
                        card:
                          - padding: 0.6em 0.8em
                          - background: none
                          - box-shadow: none
                          - border-radius: 0.8em
                          - height: 1.5em
                        custom_fields:
                          day:
                            - font-size: 0.8em
                          min:
                            - font-size: 0.8em
                          max:
                            - font-size: 0.8em
                      custom_fields:
                        day: |
                          [[[
                            const offset = variables.dayOffset || 0;
                            const today = new Date();
                            today.setUTCHours(0,0,0,0);
                            const target = new Date(today.getTime() + offset * 86400000);
                            return target.toLocaleDateString('en-GB', { weekday: 'short' });
                          ]]]
                        icon: |
                          [[[
                            const offset = variables.dayOffset || 0;
                            const hourly = entity?.attributes?.timelines?.hourly || [];
                            const iconMap = {
                              1000: 'clear-day',
                              1100: 'partly-cloudy-day',
                              1101: 'partly-cloudy-day',
                              1102: 'partly-cloudy-day',
                              1001: 'cloudy',
                              2000: 'fog',
                              2100: 'fog',
                              4000: 'drizzle',
                              4001: 'rain',
                              4200: 'rain',
                              4201: 'rain',
                              5000: 'snow',
                              5001: 'snow',
                              5100: 'snow',
                              5101: 'snow',
                              6000: 'freezing-rain',
                              6001: 'freezing-rain',
                              6200: 'freezing-rain',
                              6201: 'freezing-rain',
                              7000: 'ice-pellets',
                              7101: 'ice-pellets',
                              7102: 'ice-pellets',
                              8000: 'thunderstorm'
                            };

                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            const targetDate = new Date(today);
                            targetDate.setDate(targetDate.getDate() + offset);

                            const data = hourly.filter(h => {
                              const t = new Date(h.time);
                              return t.getFullYear() === targetDate.getFullYear() &&
                                     t.getMonth() === targetDate.getMonth() &&
                                     t.getDate() === targetDate.getDate();
                            });

                            const code = data[12]?.values?.weatherCode || 1000;
                            const icon = iconMap[code] || 'cloudy';
                            return `<img src="/local/weather-icons/weather-icons-master/design/fill/animation-ready/${icon}.svg" style="height:1.6em;" />`;
                          ]]]
                        min: |
                          [[[
                            const h = entity.attributes.timelines.hourly;
                            const offset = variables.dayOffset || 0;
                            const base = new Date();
                            base.setUTCHours(0,0,0,0);
                            const start = new Date(base.getTime() + offset * 86400000);
                            const end = new Date(start.getTime() + 86400000);
                            const temps = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            }).map(i => i.values.temperature);
                            const min = Math.min(...temps);
                            return isFinite(min) ? `${Math.round(min)}Â°C` : '';
                          ]]]
                        max: |
                          [[[
                            const h = entity.attributes.timelines.hourly;
                            const offset = variables.dayOffset || 0;
                            const base = new Date();
                            base.setUTCHours(0,0,0,0);
                            const start = new Date(base.getTime() + offset * 86400000);
                            const end = new Date(start.getTime() + 86400000);
                            const temps = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            }).map(i => i.values.temperature);
                            const max = Math.max(...temps);
                            return isFinite(max) ? `${Math.round(max)}Â°C` : '';
                          ]]]
                        bar: |
                          [[[
                            const h = entity.attributes.timelines.hourly;
                            const offset = variables.dayOffset || 0;
                            const base = new Date();
                            base.setUTCHours(0, 0, 0, 0);
                            const start = new Date(base.getTime() + offset * 86400000);
                            const end = new Date(start.getTime() + 86400000);
                            const temps = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            }).map(i => i.values.temperature);
                            if (!temps.length) return '';

                            const allTemps = entity.attributes.timelines.hourly
                              .slice(0, 120)
                              .map(i => i.values.temperature);
                            const overallMin = Math.min(...allTemps);
                            const overallMax = Math.max(...allTemps);

                            const min = Math.min(...temps);
                            const max = Math.max(...temps);
                            const left = ((min - overallMin) / (overallMax - overallMin)) * 100;
                            const rawWidth = ((max - min) / (overallMax - overallMin)) * 100;
                            const width = Math.max(rawWidth, 15);  // Ensure minimum 15% width

                            // FIX: Calculate the correct background size and position
                            // 1. Calculate how much wider the background needs to be than the bar itself.
                            //    If the bar is 50% wide, the background needs to be 200% wide.
                            const bgSize = 100 / (width / 100);

                            // 2. Calculate the horizontal position of the background.
                            //    This shifts the oversized background so the correct color slice is visible.
                            const bgPos = left / (100 - width) * 100;


                            // Rain chance
                            const rainHours = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            });
                            const rainChances = rainHours.map(i => i.values.precipitationProbability || 0);
                            const maxRain = Math.round(Math.max(...rainChances));
                            const rainLabel = `${maxRain}%`;

                            const id = Math.random().toString(36).substring(2, 9);

                            return `
                              <style>
                                @keyframes fillAnim-${id} {
                                  from { transform: scaleX(0); opacity: 0.3; }
                                  to { transform: scaleX(1); opacity: 1; }
                                }
                                @keyframes drip {
                                  0% { transform: translateY(0); opacity: 0.9; }
                                  50% { transform: translateY(2px); opacity: 0.5; }
                                  100% { transform: translateY(0); opacity: 0.9; }
                                }
                              </style>
                              <div style="
                                position: relative;
                                width: 100%;
                                height: 1.1em;
                                border-radius: 1em;
                                overflow: hidden;
                                background: rgba(255, 255, 255, 0.02);
                                backdrop-filter: blur(8px);
                                -webkit-backdrop-filter: blur(8px);
                                box-shadow:
                                  inset 0 0 1px rgba(255, 255, 255, 0.15),
                                  inset 0 0 1px rgba(144, 255, 200, 0.25);
                              ">
                                <div style="
                                  position: absolute;
                                  top: 0;
                                  bottom: 0;
                                  left: ${left}%;
                                  width: ${width}%;
                                  transform-origin: left;
                                  transform: scaleX(0);
                                  background: linear-gradient(to right, #51fcd4, #fff06e, #ffb347);
                                  /* FIX: Apply the calculated size and position */
                                  background-size: ${bgSize}% 100%;
                                  background-position: ${bgPos}% 0%;
                                  border-radius: 1em;
                                  box-shadow:
                                    inset 1px 1px 2px rgba(255, 255, 255, 0.5),
                                    inset -1px -1px 2px rgba(0, 0, 0, 0.05),
                                    0 0 8px rgba(144, 255, 200, 0.5),
                                    0 0 12px rgba(255, 170, 200, 0.2);
                                  backdrop-filter: blur(6px);
                                  -webkit-backdrop-filter: blur(6px);
                                  animation: fillAnim-${id} 1.4s ease-out 3.2s forwards;
                            
                                  display: flex;
                                  align-items: center;
                                  justify-content: center;
                                  font-size: 0.6em;
                                  font-weight: bold;
                                  color: rgba(30, 20, 80, 0.95);
                                  text-shadow: 0 0 1px rgba(255, 255, 255, 0.7);
                                ">
                                  <div style="display: flex; gap: 0.2em; align-items: center;">
                                    <span style="animation: drip 1.2s infinite ease-in-out;">ðŸ’§</span>
                                    <span>${rainLabel}</span>
                                  </div>
                                </div>
                              </div>
                            `;
                          ]]]
                    - type: custom:button-card
                      entity: sensor.tomorrow_raw_hourly
                      card_mod:
                        style: |
                          ha-card {
                            margin-bottom: -8px !important;     
                          }
                      variables:
                        dayOffset: 2
                      show_name: false
                      show_icon: false
                      show_state: false
                      layout: grid
                      styles:
                        grid:
                          - grid-template-areas: "\"day icon min bar max\""
                          - grid-template-columns: 2.5em 2em 3em 1fr 3em
                          - align-items: center
                          - column-gap: 0.4em
                        card:
                          - padding: 0.6em 0.8em
                          - background: none
                          - box-shadow: none
                          - border-radius: 0.8em
                          - height: 1.5em
                        custom_fields:
                          day:
                            - font-size: 0.8em
                          min:
                            - font-size: 0.8em
                          max:
                            - font-size: 0.8em
                      custom_fields:
                        day: |
                          [[[
                            const offset = variables.dayOffset || 0;
                            const today = new Date();
                            today.setUTCHours(0,0,0,0);
                            const target = new Date(today.getTime() + offset * 86400000);
                            return target.toLocaleDateString('en-GB', { weekday: 'short' });
                          ]]]
                        icon: |
                          [[[
                            const offset = variables.dayOffset || 0;
                            const hourly = entity?.attributes?.timelines?.hourly || [];
                            const iconMap = {
                              1000: 'clear-day',
                              1100: 'partly-cloudy-day',
                              1101: 'partly-cloudy-day',
                              1102: 'partly-cloudy-day',
                              1001: 'cloudy',
                              2000: 'fog',
                              2100: 'fog',
                              4000: 'drizzle',
                              4001: 'rain',
                              4200: 'rain',
                              4201: 'rain',
                              5000: 'snow',
                              5001: 'snow',
                              5100: 'snow',
                              5101: 'snow',
                              6000: 'freezing-rain',
                              6001: 'freezing-rain',
                              6200: 'freezing-rain',
                              6201: 'freezing-rain',
                              7000: 'ice-pellets',
                              7101: 'ice-pellets',
                              7102: 'ice-pellets',
                              8000: 'thunderstorm'
                            };

                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            const targetDate = new Date(today);
                            targetDate.setDate(targetDate.getDate() + offset);

                            const data = hourly.filter(h => {
                              const t = new Date(h.time);
                              return t.getFullYear() === targetDate.getFullYear() &&
                                     t.getMonth() === targetDate.getMonth() &&
                                     t.getDate() === targetDate.getDate();
                            });

                            const code = data[12]?.values?.weatherCode || 1000;
                            const icon = iconMap[code] || 'cloudy';
                            return `<img src="/local/weather-icons/weather-icons-master/design/fill/animation-ready/${icon}.svg" style="height:1.6em;" />`;
                          ]]]
                        min: |
                          [[[
                            const h = entity.attributes.timelines.hourly;
                            const offset = variables.dayOffset || 0;
                            const base = new Date();
                            base.setUTCHours(0,0,0,0);
                            const start = new Date(base.getTime() + offset * 86400000);
                            const end = new Date(start.getTime() + 86400000);
                            const temps = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            }).map(i => i.values.temperature);
                            const min = Math.min(...temps);
                            return isFinite(min) ? `${Math.round(min)}Â°C` : '';
                          ]]]
                        max: |
                          [[[
                            const h = entity.attributes.timelines.hourly;
                            const offset = variables.dayOffset || 0;
                            const base = new Date();
                            base.setUTCHours(0,0,0,0);
                            const start = new Date(base.getTime() + offset * 86400000);
                            const end = new Date(start.getTime() + 86400000);
                            const temps = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            }).map(i => i.values.temperature);
                            const max = Math.max(...temps);
                            return isFinite(max) ? `${Math.round(max)}Â°C` : '';
                          ]]]
                        bar: |
                          [[[
                            const h = entity.attributes.timelines.hourly;
                            const offset = variables.dayOffset || 0;
                            const base = new Date();
                            base.setUTCHours(0, 0, 0, 0);
                            const start = new Date(base.getTime() + offset * 86400000);
                            const end = new Date(start.getTime() + 86400000);
                            const temps = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            }).map(i => i.values.temperature);
                            if (!temps.length) return '';

                            const allTemps = entity.attributes.timelines.hourly
                              .slice(0, 120)
                              .map(i => i.values.temperature);
                            const overallMin = Math.min(...allTemps);
                            const overallMax = Math.max(...allTemps);

                            const min = Math.min(...temps);
                            const max = Math.max(...temps);
                            const left = ((min - overallMin) / (overallMax - overallMin)) * 100;
                            const rawWidth = ((max - min) / (overallMax - overallMin)) * 100;
                            const width = Math.max(rawWidth, 15);  // Ensure minimum 15% width

                            // FIX: Calculate the correct background size and position
                            // 1. Calculate how much wider the background needs to be than the bar itself.
                            //    If the bar is 50% wide, the background needs to be 200% wide.
                            const bgSize = 100 / (width / 100);

                            // 2. Calculate the horizontal position of the background.
                            //    This shifts the oversized background so the correct color slice is visible.
                            const bgPos = left / (100 - width) * 100;


                            // Rain chance
                            const rainHours = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            });
                            const rainChances = rainHours.map(i => i.values.precipitationProbability || 0);
                            const maxRain = Math.round(Math.max(...rainChances));
                            const rainLabel = `${maxRain}%`;

                            const id = Math.random().toString(36).substring(2, 9);

                            return `
                              <style>
                                @keyframes fillAnim-${id} {
                                  from { transform: scaleX(0); opacity: 0.3; }
                                  to { transform: scaleX(1); opacity: 1; }
                                }
                                @keyframes drip {
                                  0% { transform: translateY(0); opacity: 0.9; }
                                  50% { transform: translateY(2px); opacity: 0.5; }
                                  100% { transform: translateY(0); opacity: 0.9; }
                                }
                              </style>
                              <div style="
                                position: relative;
                                width: 100%;
                                height: 1.1em;
                                border-radius: 1em;
                                overflow: hidden;
                                background: rgba(255, 255, 255, 0.02);
                                backdrop-filter: blur(8px);
                                -webkit-backdrop-filter: blur(8px);
                                box-shadow:
                                  inset 0 0 1px rgba(255, 255, 255, 0.15),
                                  inset 0 0 1px rgba(144, 255, 200, 0.25);
                              ">
                                <div style="
                                  position: absolute;
                                  top: 0;
                                  bottom: 0;
                                  left: ${left}%;
                                  width: ${width}%;
                                  transform-origin: left;
                                  transform: scaleX(0);
                                  background: linear-gradient(to right, #51fcd4, #fff06e, #ffb347);
                                  /* FIX: Apply the calculated size and position */
                                  background-size: ${bgSize}% 100%;
                                  background-position: ${bgPos}% 0%;
                                  border-radius: 1em;
                                  box-shadow:
                                    inset 1px 1px 2px rgba(255, 255, 255, 0.5),
                                    inset -1px -1px 2px rgba(0, 0, 0, 0.05),
                                    0 0 8px rgba(144, 255, 200, 0.5),
                                    0 0 12px rgba(255, 170, 200, 0.2);
                                  backdrop-filter: blur(6px);
                                  -webkit-backdrop-filter: blur(6px);
                                  animation: fillAnim-${id} 1.4s ease-out 3.2s forwards;
                            
                                  display: flex;
                                  align-items: center;
                                  justify-content: center;
                                  font-size: 0.6em;
                                  font-weight: bold;
                                  color: rgba(30, 20, 80, 0.95);
                                  text-shadow: 0 0 1px rgba(255, 255, 255, 0.7);
                                ">
                                  <div style="display: flex; gap: 0.2em; align-items: center;">
                                    <span style="animation: drip 1.2s infinite ease-in-out;">ðŸ’§</span>
                                    <span>${rainLabel}</span>
                                  </div>
                                </div>
                              </div>
                            `;
                          ]]]
                    - type: custom:button-card
                      entity: sensor.tomorrow_raw_hourly
                      card_mod:
                        style: |
                          ha-card {
                            margin-bottom: -8px !important;     
                          }
                      variables:
                        dayOffset: 3
                      show_name: false
                      show_icon: false
                      show_state: false
                      layout: grid
                      styles:
                        grid:
                          - grid-template-areas: "\"day icon min bar max\""
                          - grid-template-columns: 2.5em 2em 3em 1fr 3em
                          - align-items: center
                          - column-gap: 0.4em
                        card:
                          - padding: 0.6em 0.8em
                          - background: none
                          - box-shadow: none
                          - border-radius: 0.8em
                          - height: 1.5em
                        custom_fields:
                          day:
                            - font-size: 0.8em
                          min:
                            - font-size: 0.8em
                          max:
                            - font-size: 0.8em
                      custom_fields:
                        day: |
                          [[[
                            const offset = variables.dayOffset || 0;
                            const today = new Date();
                            today.setUTCHours(0,0,0,0);
                            const target = new Date(today.getTime() + offset * 86400000);
                            return target.toLocaleDateString('en-GB', { weekday: 'short' });
                          ]]]
                        icon: |
                          [[[
                            const offset = variables.dayOffset || 0;
                            const hourly = entity?.attributes?.timelines?.hourly || [];
                            const iconMap = {
                              1000: 'clear-day',
                              1100: 'partly-cloudy-day',
                              1101: 'partly-cloudy-day',
                              1102: 'partly-cloudy-day',
                              1001: 'cloudy',
                              2000: 'fog',
                              2100: 'fog',
                              4000: 'drizzle',
                              4001: 'rain',
                              4200: 'rain',
                              4201: 'rain',
                              5000: 'snow',
                              5001: 'snow',
                              5100: 'snow',
                              5101: 'snow',
                              6000: 'freezing-rain',
                              6001: 'freezing-rain',
                              6200: 'freezing-rain',
                              6201: 'freezing-rain',
                              7000: 'ice-pellets',
                              7101: 'ice-pellets',
                              7102: 'ice-pellets',
                              8000: 'thunderstorm'
                            };

                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            const targetDate = new Date(today);
                            targetDate.setDate(targetDate.getDate() + offset);

                            const data = hourly.filter(h => {
                              const t = new Date(h.time);
                              return t.getFullYear() === targetDate.getFullYear() &&
                                     t.getMonth() === targetDate.getMonth() &&
                                     t.getDate() === targetDate.getDate();
                            });

                            const code = data[12]?.values?.weatherCode || 1000;
                            const icon = iconMap[code] || 'cloudy';
                            return `<img src="/local/weather-icons/weather-icons-master/design/fill/animation-ready/${icon}.svg" style="height:1.6em;" />`;
                          ]]]
                        min: |
                          [[[
                            const h = entity.attributes.timelines.hourly;
                            const offset = variables.dayOffset || 0;
                            const base = new Date();
                            base.setUTCHours(0,0,0,0);
                            const start = new Date(base.getTime() + offset * 86400000);
                            const end = new Date(start.getTime() + 86400000);
                            const temps = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            }).map(i => i.values.temperature);
                            const min = Math.min(...temps);
                            return isFinite(min) ? `${Math.round(min)}Â°C` : '';
                          ]]]
                        max: |
                          [[[
                            const h = entity.attributes.timelines.hourly;
                            const offset = variables.dayOffset || 0;
                            const base = new Date();
                            base.setUTCHours(0,0,0,0);
                            const start = new Date(base.getTime() + offset * 86400000);
                            const end = new Date(start.getTime() + 86400000);
                            const temps = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            }).map(i => i.values.temperature);
                            const max = Math.max(...temps);
                            return isFinite(max) ? `${Math.round(max)}Â°C` : '';
                          ]]]
                        bar: |
                          [[[
                            const h = entity.attributes.timelines.hourly;
                            const offset = variables.dayOffset || 0;
                            const base = new Date();
                            base.setUTCHours(0, 0, 0, 0);
                            const start = new Date(base.getTime() + offset * 86400000);
                            const end = new Date(start.getTime() + 86400000);
                            const temps = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            }).map(i => i.values.temperature);
                            if (!temps.length) return '';

                            const allTemps = entity.attributes.timelines.hourly
                              .slice(0, 120)
                              .map(i => i.values.temperature);
                            const overallMin = Math.min(...allTemps);
                            const overallMax = Math.max(...allTemps);

                            const min = Math.min(...temps);
                            const max = Math.max(...temps);
                            const left = ((min - overallMin) / (overallMax - overallMin)) * 100;
                            const rawWidth = ((max - min) / (overallMax - overallMin)) * 100;
                            const width = Math.max(rawWidth, 15);  // Ensure minimum 15% width

                            // FIX: Calculate the correct background size and position
                            // 1. Calculate how much wider the background needs to be than the bar itself.
                            //    If the bar is 50% wide, the background needs to be 200% wide.
                            const bgSize = 100 / (width / 100);

                            // 2. Calculate the horizontal position of the background.
                            //    This shifts the oversized background so the correct color slice is visible.
                            const bgPos = left / (100 - width) * 100;


                            // Rain chance
                            const rainHours = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            });
                            const rainChances = rainHours.map(i => i.values.precipitationProbability || 0);
                            const maxRain = Math.round(Math.max(...rainChances));
                            const rainLabel = `${maxRain}%`;

                            const id = Math.random().toString(36).substring(2, 9);

                            return `
                              <style>
                                @keyframes fillAnim-${id} {
                                  from { transform: scaleX(0); opacity: 0.3; }
                                  to { transform: scaleX(1); opacity: 1; }
                                }
                                @keyframes drip {
                                  0% { transform: translateY(0); opacity: 0.9; }
                                  50% { transform: translateY(2px); opacity: 0.5; }
                                  100% { transform: translateY(0); opacity: 0.9; }
                                }
                              </style>
                              <div style="
                                position: relative;
                                width: 100%;
                                height: 1.1em;
                                border-radius: 1em;
                                overflow: hidden;
                                background: rgba(255, 255, 255, 0.02);
                                backdrop-filter: blur(8px);
                                -webkit-backdrop-filter: blur(8px);
                                box-shadow:
                                  inset 0 0 1px rgba(255, 255, 255, 0.15),
                                  inset 0 0 1px rgba(144, 255, 200, 0.25);
                              ">
                                <div style="
                                  position: absolute;
                                  top: 0;
                                  bottom: 0;
                                  left: ${left}%;
                                  width: ${width}%;
                                  transform-origin: left;
                                  transform: scaleX(0);
                                  background: linear-gradient(to right, #51fcd4, #fff06e, #ffb347);
                                  /* FIX: Apply the calculated size and position */
                                  background-size: ${bgSize}% 100%;
                                  background-position: ${bgPos}% 0%;
                                  border-radius: 1em;
                                  box-shadow:
                                    inset 1px 1px 2px rgba(255, 255, 255, 0.5),
                                    inset -1px -1px 2px rgba(0, 0, 0, 0.05),
                                    0 0 8px rgba(144, 255, 200, 0.5),
                                    0 0 12px rgba(255, 170, 200, 0.2);
                                  backdrop-filter: blur(6px);
                                  -webkit-backdrop-filter: blur(6px);
                                  animation: fillAnim-${id} 1.4s ease-out 3.2s forwards;
                            
                                  display: flex;
                                  align-items: center;
                                  justify-content: center;
                                  font-size: 0.6em;
                                  font-weight: bold;
                                  color: rgba(30, 20, 80, 0.95);
                                  text-shadow: 0 0 1px rgba(255, 255, 255, 0.7);
                                ">
                                  <div style="display: flex; gap: 0.2em; align-items: center;">
                                    <span style="animation: drip 1.2s infinite ease-in-out;">ðŸ’§</span>
                                    <span>${rainLabel}</span>
                                  </div>
                                </div>
                              </div>
                            `;
                          ]]]
                    - type: custom:button-card
                      entity: sensor.tomorrow_raw_hourly
                      variables:
                        dayOffset: 4
                      show_name: false
                      show_icon: false
                      show_state: false
                      layout: grid
                      styles:
                        grid:
                          - grid-template-areas: "\"day icon min bar max\""
                          - grid-template-columns: 2.5em 2em 3em 1fr 3em
                          - align-items: center
                          - column-gap: 0.4em
                        card:
                          - padding: 0.6em 0.8em
                          - background: none
                          - box-shadow: none
                          - border-radius: 0.8em
                          - height: 1.5em
                        custom_fields:
                          day:
                            - font-size: 0.8em
                          min:
                            - font-size: 0.8em
                          max:
                            - font-size: 0.8em
                      custom_fields:
                        day: |
                          [[[
                            const offset = variables.dayOffset || 0;
                            const today = new Date();
                            today.setUTCHours(0,0,0,0);
                            const target = new Date(today.getTime() + offset * 86400000);
                            return target.toLocaleDateString('en-GB', { weekday: 'short' });
                          ]]]
                        icon: |
                          [[[
                            const offset = variables.dayOffset || 0;
                            const hourly = entity?.attributes?.timelines?.hourly || [];
                            const iconMap = {
                              1000: 'clear-day',
                              1100: 'partly-cloudy-day',
                              1101: 'partly-cloudy-day',
                              1102: 'partly-cloudy-day',
                              1001: 'cloudy',
                              2000: 'fog',
                              2100: 'fog',
                              4000: 'drizzle',
                              4001: 'rain',
                              4200: 'rain',
                              4201: 'rain',
                              5000: 'snow',
                              5001: 'snow',
                              5100: 'snow',
                              5101: 'snow',
                              6000: 'freezing-rain',
                              6001: 'freezing-rain',
                              6200: 'freezing-rain',
                              6201: 'freezing-rain',
                              7000: 'ice-pellets',
                              7101: 'ice-pellets',
                              7102: 'ice-pellets',
                              8000: 'thunderstorm'
                            };

                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            const targetDate = new Date(today);
                            targetDate.setDate(targetDate.getDate() + offset);

                            const data = hourly.filter(h => {
                              const t = new Date(h.time);
                              return t.getFullYear() === targetDate.getFullYear() &&
                                     t.getMonth() === targetDate.getMonth() &&
                                     t.getDate() === targetDate.getDate();
                            });

                            const code = data[12]?.values?.weatherCode || 1000;
                            const icon = iconMap[code] || 'cloudy';
                            return `<img src="/local/weather-icons/weather-icons-master/design/fill/animation-ready/${icon}.svg" style="height:1.6em;" />`;
                          ]]]
                        min: |
                          [[[
                            const h = entity.attributes.timelines.hourly;
                            const offset = variables.dayOffset || 0;
                            const base = new Date();
                            base.setUTCHours(0,0,0,0);
                            const start = new Date(base.getTime() + offset * 86400000);
                            const end = new Date(start.getTime() + 86400000);
                            const temps = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            }).map(i => i.values.temperature);
                            const min = Math.min(...temps);
                            return isFinite(min) ? `${Math.round(min)}Â°C` : '';
                          ]]]
                        max: |
                          [[[
                            const h = entity.attributes.timelines.hourly;
                            const offset = variables.dayOffset || 0;
                            const base = new Date();
                            base.setUTCHours(0,0,0,0);
                            const start = new Date(base.getTime() + offset * 86400000);
                            const end = new Date(start.getTime() + 86400000);
                            const temps = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            }).map(i => i.values.temperature);
                            const max = Math.max(...temps);
                            return isFinite(max) ? `${Math.round(max)}Â°C` : '';
                          ]]]
                        bar: |
                          [[[
                            const h = entity.attributes.timelines.hourly;
                            const offset = variables.dayOffset || 0;
                            const base = new Date();
                            base.setUTCHours(0, 0, 0, 0);
                            const start = new Date(base.getTime() + offset * 86400000);
                            const end = new Date(start.getTime() + 86400000);
                            const temps = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            }).map(i => i.values.temperature);
                            if (!temps.length) return '';

                            const allTemps = entity.attributes.timelines.hourly
                              .slice(0, 120)
                              .map(i => i.values.temperature);
                            const overallMin = Math.min(...allTemps);
                            const overallMax = Math.max(...allTemps);

                            const min = Math.min(...temps);
                            const max = Math.max(...temps);
                            const left = ((min - overallMin) / (overallMax - overallMin)) * 100;
                            const rawWidth = ((max - min) / (overallMax - overallMin)) * 100;
                            const width = Math.max(rawWidth, 15);  // Ensure minimum 15% width

                            // FIX: Calculate the correct background size and position
                            // 1. Calculate how much wider the background needs to be than the bar itself.
                            //    If the bar is 50% wide, the background needs to be 200% wide.
                            const bgSize = 100 / (width / 100);

                            // 2. Calculate the horizontal position of the background.
                            //    This shifts the oversized background so the correct color slice is visible.
                            const bgPos = left / (100 - width) * 100;


                            // Rain chance
                            const rainHours = h.filter(i => {
                              const t = new Date(i.time);
                              return t >= start && t < end;
                            });
                            const rainChances = rainHours.map(i => i.values.precipitationProbability || 0);
                            const maxRain = Math.round(Math.max(...rainChances));
                            const rainLabel = `${maxRain}%`;

                            const id = Math.random().toString(36).substring(2, 9);

                            return `
                              <style>
                                @keyframes fillAnim-${id} {
                                  from { transform: scaleX(0); opacity: 0.3; }
                                  to { transform: scaleX(1); opacity: 1; }
                                }
                                @keyframes drip {
                                  0% { transform: translateY(0); opacity: 0.9; }
                                  50% { transform: translateY(2px); opacity: 0.5; }
                                  100% { transform: translateY(0); opacity: 0.9; }
                                }
                              </style>
                              <div style="
                                position: relative;
                                width: 100%;
                                height: 1.1em;
                                border-radius: 1em;
                                overflow: hidden;
                                background: rgba(255, 255, 255, 0.02);
                                backdrop-filter: blur(8px);
                                -webkit-backdrop-filter: blur(8px);
                                box-shadow:
                                  inset 0 0 1px rgba(255, 255, 255, 0.15),
                                  inset 0 0 1px rgba(144, 255, 200, 0.25);
                              ">
                                <div style="
                                  position: absolute;
                                  top: 0;
                                  bottom: 0;
                                  left: ${left}%;
                                  width: ${width}%;
                                  transform-origin: left;
                                  transform: scaleX(0);
                                  background: linear-gradient(to right, #51fcd4, #fff06e, #ffb347);
                                  /* FIX: Apply the calculated size and position */
                                  background-size: ${bgSize}% 100%;
                                  background-position: ${bgPos}% 0%;
                                  border-radius: 1em;
                                  box-shadow:
                                    inset 1px 1px 2px rgba(255, 255, 255, 0.5),
                                    inset -1px -1px 2px rgba(0, 0, 0, 0.05),
                                    0 0 8px rgba(144, 255, 200, 0.5),
                                    0 0 12px rgba(255, 170, 200, 0.2);
                                  backdrop-filter: blur(6px);
                                  -webkit-backdrop-filter: blur(6px);
                                  animation: fillAnim-${id} 1.4s ease-out 3.2s forwards;
                            
                                  display: flex;
                                  align-items: center;
                                  justify-content: center;
                                  font-size: 0.6em;
                                  font-weight: bold;
                                  color: rgba(30, 20, 80, 0.95);
                                  text-shadow: 0 0 1px rgba(255, 255, 255, 0.7);
                                ">
                                  <div style="display: flex; gap: 0.2em; align-items: center;">
                                    <span style="animation: drip 1.2s infinite ease-in-out;">ðŸ’§</span>
                                    <span>${rainLabel}</span>
                                  </div>
                                </div>
                              </div>
                            `;
                          ]]]
              - type: custom:button-card
                styles:
                  card:
                    - background: none
                    - border-radius: 1.5rem
                    - box-shadow: >
                        inset 0 0 8px rgba(255,255,255,0.03), 0 6px 20px
                        rgba(0,0,0,0.4)
                    - overflow: hidden
                    - position: relative
                custom_fields:
                  chart: |
                    [[[
                      // Responsive width: use the card's width, fallback to 480 if not available
                      const card = this;
                      const width = 480;
                      const height = 90;
                      const leftMargin = 20;
                      const rightMargin = 10;
                      const topPadding = 20;
                      const bottomPadding = 20;

                      const raw = states['sensor.tomorrow_raw_hourly'];
                      const timeline = raw?.attributes?.timelines?.hourly?.slice(0, 12) ?? [];
                      const temps = timeline.map(x => x.values.temperature);
                      const times = timeline.map(x => new Date(x.time).getHours());

                      const minTemp = Math.min(...temps);
                      const maxTemp = Math.max(...temps);
                      const range = maxTemp - minTemp || 1;

                      const points = temps.map((t, i) => {
                        const x = leftMargin + (i / (temps.length - 1)) * (width - leftMargin - rightMargin);
                        const y = topPadding + (1 - (t - minTemp) / range) * (height - topPadding - bottomPadding);
                        return [x, y];
                      });

                      const linePath = points.map((p, i, a) => {
                        if (i === 0) return `M ${p[0]},${p[1]}`;
                        const [x1, y1] = a[i - 1];
                        const [x2, y2] = p;
                        const mx = (x1 + x2) / 2;
                        return `Q ${x1},${y1} ${mx},${(y1 + y2) / 2}`;
                      }).join(' ');

                      const areaPath = 
                        `M ${leftMargin - 20},${height}
                        Q ${leftMargin - 10},${points[0][1] + 10} ${points[0][0]},${points[0][1]}
                        ${points.map((p, i, a) => {
                          if (i === 0) return '';
                          const [x1, y1] = a[i - 1];
                          const [x2, y2] = p;
                          const mx = (x1 + x2) / 2;
                          return `Q ${x1},${y1} ${mx},${(y1 + y2) / 2}`;
                        }).join(' ')}
                        L ${points[points.length - 1][0]},${height}
                        Z`
                      ;

                      return `
                        <svg width="100%" height="${height}" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" style="display:block;margin:0 auto;">
                          <defs>
                            <linearGradient id="tempLine" x1="0" y1="0" x2="1" y2="0">
                              <stop offset="0%" stop-color="#ffc658"/>
                              <stop offset="100%" stop-color="#ff7300"/>
                            </linearGradient>
                            <linearGradient id="tempArea" x1="0" y1="0" x2="0" y2="1">
                              <stop offset="0%" stop-color="#ff8c00" stop-opacity="0.25"/>
                              <stop offset="100%" stop-color="#ff8c00" stop-opacity="0"/>
                            </linearGradient>
                            <filter id="shadow">
                              <feDropShadow dx="0" dy="1" stdDeviation="1.5" flood-color="rgba(0,0,0,0.3)" />
                            </filter>
                          </defs>

                          <path d="${areaPath}" fill="url(#tempArea)"/>

                          <path d="${linePath}" fill="none" stroke="url(#tempLine)" stroke-width="2.5" stroke-linecap="round"
                                filter="url(#shadow)" stroke-dasharray="1000" stroke-dashoffset="1000">
                            <animate attributeName="stroke-dashoffset" from="1000" to="0" dur="3s" begin="4.5s" fill="freeze" />
                          </path>

                          ${points.map(([x, y], i) => i % 2 === 0 ? 
                            `<circle cx="${x}" cy="${y}" r="0" fill="white" stroke="url(#tempLine)" stroke-width="2.5" visibility="hidden">
                              <set attributeName="visibility" to="visible" begin="4s" />
                              <animate attributeName="r" values="0;4.5" dur="0.3s" begin="4s" fill="freeze" />
                            </circle>` : '').join('')}

                          ${points.map(([x, y], i) => i % 2 === 0 ? 
                            `<text x="${x}" y="${y - 10}" text-anchor="middle" font-size="13" fill="white"
                                  style="font-weight: 500; text-shadow: 0 0 2px rgba(0,0,0,0.4);">
                              ${temps[i].toFixed(1)}Â°
                            </text>` : '').join('')}

                          ${points.map(([x], i) => i % 2 === 0 ? 
                            `<text x="${x}" y="${height - 1}" text-anchor="middle" font-size="11" fill="white" style="opacity: 0.6;">
                              ${String(times[i]).padStart(2, '0')}:00
                            </text>` : '').join('')}
                        </svg>
                      `;
                    ]]]
                show_icon: false
                show_name: false
                show_state: false
                card_mod:
                  style: |
                    ha-card {
                      width: 100% !important;
                      max-width: 100vw !important;
                      min-width: 0 !important;
                      background: none !important;
                      box-shadow: none !important;
                      margin-bottom: -30px !important;
                      margin-top: -24px !important;
                      
                    }
